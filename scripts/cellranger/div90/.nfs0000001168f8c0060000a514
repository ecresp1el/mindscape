#!/usr/bin/env bash
set -euo pipefail

# Monitor a Slurm job and write concise status updates to a log file.
# Usage: JOB_NAME=<name> LOG_DIR=<dir> ./monitor_job.sh <JOB_ID> [INTERVAL_SEC]

JOB_ID="${1:-}"
INTERVAL="${2:-60}"

if [[ -z "$JOB_ID" ]]; then
  echo "Usage: JOB_NAME=<name> LOG_DIR=<dir> $0 <JOB_ID> [INTERVAL_SEC]" >&2
  exit 1
fi

JOB_NAME_EFF=${JOB_NAME:-cellranger_multi_div90}
LOG_DIR_EFF=${LOG_DIR:-./logs}
mkdir -p "$LOG_DIR_EFF"
STATUS_FILE="$LOG_DIR_EFF/${JOB_NAME_EFF}_${JOB_ID}.status"

touch "$STATUS_FILE"
echo "Watching Slurm job $JOB_ID (every ${INTERVAL}s)" >> "$STATUS_FILE"

last_state=""
terminal_regex='COMPLETED|FAILED|CANCELLED|TIMEOUT|OUT_OF_ME+|PREEMPTED'

while :; do
  # Prefer squeue for active jobs
  if squeue -j "$JOB_ID" -h >/dev/null 2>&1; then
    line=$(squeue -j "$JOB_ID" -h -o '%T %M %R') || line=""
  else
    line=""
  fi

  if [[ -z "$line" ]]; then
    # Fall back to sacct when not in queue (finished or accounting only)
    state=$(sacct -j "$JOB_ID" -o State -n -X 2>/dev/null | head -n1 | awk '{print $1}')
    if [[ -z "$state" ]]; then
      state="UNKNOWN"
    fi
    if [[ "$state" != "$last_state" ]]; then
      echo "[$(date '+%F %T')] state=$state (accounting)" >> "$STATUS_FILE"
      last_state="$state"
    fi
    [[ "$state" =~ $terminal_regex ]] && break
  else
    state=$(awk '{print $1}' <<<"$line")
    runtime=$(awk '{print $2}' <<<"$line")
    reason=$(awk '{print substr($0, index($0,$3))}' <<<"$line")
    if [[ "$state" != "$last_state" ]]; then
      echo "[$(date '+%F %T')] state=$state runtime=$runtime reason=$reason" >> "$STATUS_FILE"
      last_state="$state"
    fi
  fi
  sleep "$INTERVAL"
done

echo "[$(date '+%F %T')] monitoring finished (terminal state detected)" >> "$STATUS_FILE"

