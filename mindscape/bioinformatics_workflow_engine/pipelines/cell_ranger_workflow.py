import yaml
from pathlib import Path
import shutil
import subprocess
import tempfile
from .base_workflow import BaseWorkflow

class CellRangerWorkflow(BaseWorkflow):
    """
    A workflow for running Cell Ranger's `multi` pipeline using a patched `multi_config.csv` file.

    This workflow is specifically designed for DIV 90 ventral SOSR organoid samples. It uses FASTQ files
    that were provided by the sequencing core and assumes that the required `multi_config.csv` has been
    manually prepared by the user.

    The CSV file must conform to 10x FLEX Genomics' required format, including properly annotated
    [gene-expression], [libraries], and [samples] sections. The workflow copies this file,
    patches required parameters (e.g., create-bam, reference, probe-set), and runs Cell Ranger using the modified file.
    """
    def __init__(self, config):
        super().__init__(config)
        self.workflow_name = "CellRangerWorkflow"
        self.setup_paths()

        if not self.config.get("force_rerun", False) and self.is_already_completed():
            print(f"‚úÖ Skipping {self.workflow_name}; already completed.")
            self._skip_execution = True
        else:
            self._skip_execution = False

        self.use_slurm = True  # Use SLURM for job management

        # Load the configuration if a path is provided
        if isinstance(config, str) or isinstance(config, Path):
            with open(config, "r") as file:
                config = yaml.safe_load(file)

        self.workflow_name = "CellRangerWorkflow"

        # Base paths and subpaths
        self.project_path = Path(config["project_path"])
        self.results_dir = self.project_path / "results" / f"cellranger_multi_{self.workflow_name}"
        self.logs_dir = self.project_path / "logs"

        # Reference genome and other files
        self.turbo_ref_base = "/nfs/turbo/umms-parent/10X_Human_Refs"
        self.ref_subpath = "2020-A/Ref_genome/refdata-gex-GRCh38-2020-A"
        self.ref_genome = Path(self.turbo_ref_base) / self.ref_subpath

        # ‚ö†Ô∏è WARNING: This CSV file is manually curated and must exist at the specified location.
        # It must follow 10x Genomics' `multi` CSV format and include valid sample, fastq, and barcode information.
        # This file is NOT generated by the workflow ‚Äî ensure is in this location before running the workflow.
        # The multi_config_source should be a path to the manually curated multi_config.csv file.
        self.multi_config_source = "/nfs/turbo/umms-parent/Accessible_multi-config_csvs/Carmen_Miranda_scRNAseq /90 Day results/fastqs_10496-MW/multi-config.csv"
        self.probe_file = "/nfs/turbo/umms-parent/10X_Human_Refs/2020-A/Probe_set/Chromium_Human_Transcriptome_Probe_Set_v1.0.1_GRCh38-2020-A.csv"
        self.output_id = "10496-MW-reanalysis"

    def validate_paths(self):
        """Validate that required paths exist."""
        # Validate reference genome
        if not self.ref_genome.exists():
            raise FileNotFoundError(f"‚ùå ERROR: Reference folder not found at {self.ref_genome}")
        print(f"üß¨ Using reference genome: {self.ref_genome}")

        # Validate multi_config.csv source
        print(f"DEBUG: Checking multi-config source path: {self.multi_config_source}")
        if not Path(self.multi_config_source).exists():
            raise FileNotFoundError(f"‚ùå ERROR: Multi-config file not found at {self.multi_config_source}")
        print(f"üìÑ Multi-config source found: {self.multi_config_source}")

        # Validate probe file
        if not Path(self.probe_file).exists():
            raise FileNotFoundError(f"‚ùå ERROR: Probe file not found at {self.probe_file}")
        print(f"üß¨ Probe file found: {self.probe_file}")

    def prepare_multi_config(self):
        """
        Copies the manually curated multi_config.csv to a stable config path and injects required parameters.

        This function assumes the source multi_config.csv is well-structured and includes all needed sections.
        It inserts 10x-required fields like `create-bam`, `reference`, and `probe-set` under the [gene-expression] section.
        """
        config_dest = self.project_path / "config" / "cellranger_multi_config.csv"
        config_dest.parent.mkdir(parents=True, exist_ok=True)

        # Ensure the results directory exists
        print(f"Ensuring results directory exists: {self.results_dir}")
        self.results_dir.mkdir(parents=True, exist_ok=True)

        # Copy the multi_config.csv file
        print(f"Copying multi_config.csv from {self.multi_config_source} to {config_dest}")
        try:
            shutil.copy(self.multi_config_source, config_dest)
        except Exception as e:
            raise RuntimeError(f"Failed to copy multi_config.csv: {e}")

        # Verify the file was copied
        if not config_dest.exists():
            raise FileNotFoundError(f"multi_config.csv was not copied to {config_dest}")

        # Debug: Print the copied file before patching
        print("Copied multi_config.csv before patching:")
        with open(config_dest, "r") as file:
            print(file.read())

        # Patch the multi_config.csv file
        print("Patching multi_config.csv...")
        with open(config_dest, "r") as file:
            lines = file.readlines()

        patched_lines = []
        in_gene_expression = False
        section_replaced = False

        for line in lines:
            stripped = line.strip()

            if stripped == "[gene-expression]":
                # Start of gene-expression section
                in_gene_expression = True
                continue  # Skip this header for now

            # If another section begins, insert new gene-expression section before continuing
            if stripped.startswith("[") and in_gene_expression and not section_replaced:
                patched_lines.append("[gene-expression]\n")
                patched_lines.append("create-bam,true\n")
                patched_lines.append(f"reference,{self.ref_genome}\n")
                patched_lines.append(f"probe-set,{self.probe_file}\n")
                section_replaced = True
                in_gene_expression = False

            if not in_gene_expression:
                patched_lines.append(line)

        # Edge case: if gene-expression was last section and never replaced
        if in_gene_expression and not section_replaced:
            patched_lines.append("[gene-expression]\n")
            patched_lines.append("create-bam,true\n")
            patched_lines.append(f"reference,{self.ref_genome}\n")
            patched_lines.append(f"probe-set,{self.probe_file}\n")

        with open(config_dest, "w") as file:
            file.writelines(patched_lines)

        # Debug: Print the patched file
        print("Patched multi_config.csv:")
        with open(config_dest, "r") as file:
            print(file.read())
        
    def build_cellranger_command(self):
        """Build the full shell command for SLURM submission."""
        module_commands = (
            "set +u && "
            "module purge && "
            "module load Bioinformatics cellranger && "
            "module load snakemake && "
            "set -u"
        )

        config_file = self.project_path / "config" / "cellranger_multi_config.csv"
        output_dir = self.results_dir

        quoted_config_file = f'"{config_file}"'
        quoted_output_dir = f'"{output_dir}"'
        
        #parse memory string (e.g 64G) to integer GB
        mem_value = int(str(self.slurm_mem).replace("G", "").replace("g", "").replace(" ", "")) 
        
        # Build the Cell Ranger command
        # note that the spaces are critical here, as they are used to separate the parameters in the command
        cellranger_command = (
            f"cellranger multi --id={self.output_id} "
            f"--csv={quoted_config_file} "
            f"--output-dir={quoted_output_dir} "
            f"--localcores={self.slurm_cpus} "
            f"--localmem={mem_value} "
        )

        return f"{module_commands} && cd {quoted_output_dir} && {cellranger_command}"

    def run(self):
        """Execute the Cell Ranger workflow."""
        if self._skip_execution:
            return
        self.log_start()
        print(f"üî¨ Starting {self.workflow_name}...")
        self.validate_paths()
        self.prepare_multi_config()
        command = self.build_cellranger_command()
        dry_run = self.config.get("dry_run", True)

        job_id = self.submit_job(
            command=command,
            job_name=f"cellranger_{self.output_id}",
            dry_run=dry_run #driven by the config.yaml file or CLI user input via MINDSCAPE_DRY_RUN environment variable
        )
        
        if job_id:
            print(f"‚úÖ SLURM job submitted for {self.workflow_name} (Job ID: {job_id})")
        else:
            print(f"‚úÖ Job for {self.workflow_name} was run locally or as a dry run.")
        
        self.log_end()
        print(f"‚úÖ {self.workflow_name} completed successfully!")