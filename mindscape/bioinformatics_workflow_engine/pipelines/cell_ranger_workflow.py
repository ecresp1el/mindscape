import yaml
from pathlib import Path
import shutil
import subprocess
import tempfile
from .base_workflow import BaseWorkflow

class CellRangerWorkflow(BaseWorkflow):
    """
    A workflow for running Cell Ranger's `multi` pipeline using a patched `multi_config.csv` file.

    This workflow is specifically designed for DIV 90 ventral SOSR organoid samples. It uses FASTQ files
    that were provided by the sequencing core and assumes that the required `multi_config.csv` has been
    manually prepared by the user.

    The CSV file must conform to 10x FLEX Genomics' required format, including properly annotated
    [gene-expression], [libraries], and [samples] sections. The workflow copies this file,
    patches required parameters (e.g., create-bam, reference, probe-set), and runs Cell Ranger using the modified file.
    """
    def __init__(self, config):
        super().__init__(config)
        self.use_slurm = True  # Use SLURM for job management

        # Load the configuration if a path is provided
        if isinstance(config, str) or isinstance(config, Path):
            with open(config, "r") as file:
                config = yaml.safe_load(file)

        self.workflow_name = "CellRangerWorkflow"

        # Base paths and subpaths
        self.project_path = Path(config["project_path"])
        self.results_dir = self.project_path / "results" / f"cellranger_multi_{self.workflow_name}"
        self.logs_dir = self.project_path / "logs"

        # Reference genome and other files
        self.turbo_ref_base = "/nfs/turbo/umms-parent/10X_Human_Refs"
        self.ref_subpath = "2020-A/Ref_genome/refdata-gex-GRCh38-2020-A"
        self.ref_genome = Path(self.turbo_ref_base) / self.ref_subpath

        # ‚ö†Ô∏è WARNING: This CSV file is manually curated and must exist at the specified location.
        # It must follow 10x Genomics' `multi` CSV format and include valid sample, fastq, and barcode information.
        # This file is NOT generated by the workflow ‚Äî ensure is in this location before running the workflow.
        # The multi_config_source should be a path to the manually curated multi_config.csv file.
        self.multi_config_source = "/nfs/turbo/umms-parent/Accessible_multi-config_csvs/Carmen_Miranda_scRNAseq /90 Day results/fastqs_10496-MW/multi-config.csv"
        self.probe_file = "/nfs/turbo/umms-parent/10X_Human_Refs/2020-A/Probe_set/Chromium_Human_Transcriptome_Probe_Set_v1.0.1_GRCh38-2020-A.csv"
        self.output_id = "10496-MW-reanalysis"

    def validate_paths(self):
        """Validate that required paths exist."""
        # Validate reference genome
        if not self.ref_genome.exists():
            raise FileNotFoundError(f"‚ùå ERROR: Reference folder not found at {self.ref_genome}")
        print(f"üß¨ Using reference genome: {self.ref_genome}")

        # Validate multi_config.csv source
        print(f"DEBUG: Checking multi-config source path: {self.multi_config_source}")
        if not Path(self.multi_config_source).exists():
            raise FileNotFoundError(f"‚ùå ERROR: Multi-config file not found at {self.multi_config_source}")
        print(f"üìÑ Multi-config source found: {self.multi_config_source}")

        # Validate probe file
        if not Path(self.probe_file).exists():
            raise FileNotFoundError(f"‚ùå ERROR: Probe file not found at {self.probe_file}")
        print(f"üß¨ Probe file found: {self.probe_file}")

    def prepare_multi_config(self):
        """
        Copies the manually curated multi_config.csv to a stable config path and injects required parameters.

        This function assumes the source multi_config.csv is well-structured and includes all needed sections.
        It inserts 10x-required fields like `create-bam`, `reference`, and `probe-set` under the [gene-expression] section.
        """
        config_dest = self.project_path / "config" / "cellranger_multi_config.csv"
        config_dest.parent.mkdir(parents=True, exist_ok=True)

        # Ensure the results directory exists
        print(f"Ensuring results directory exists: {self.results_dir}")
        self.results_dir.mkdir(parents=True, exist_ok=True)

        # Copy the multi_config.csv file
        print(f"Copying multi_config.csv from {self.multi_config_source} to {config_dest}")
        try:
            shutil.copy(self.multi_config_source, config_dest)
        except Exception as e:
            raise RuntimeError(f"Failed to copy multi_config.csv: {e}")

        # Verify the file was copied
        if not config_dest.exists():
            raise FileNotFoundError(f"multi_config.csv was not copied to {config_dest}")

        # Debug: Print the copied file before patching
        print("Copied multi_config.csv before patching:")
        with open(config_dest, "r") as file:
            print(file.read())

        # Patch the multi_config.csv file
        print("Patching multi_config.csv...")
        with open(config_dest, "r") as file:
            lines = file.readlines()

        patched_lines = []
        in_gene_expression = False
        section_replaced = False

        for line in lines:
            stripped = line.strip()

            if stripped == "[gene-expression]":
                # Start of gene-expression section
                in_gene_expression = True
                continue  # Skip this header for now

            # If another section begins, insert new gene-expression section before continuing
            if stripped.startswith("[") and in_gene_expression and not section_replaced:
                patched_lines.append("[gene-expression]\n")
                patched_lines.append("create-bam,true\n")
                patched_lines.append(f"reference,{self.ref_genome}\n")
                patched_lines.append(f"probe-set,{self.probe_file}\n")
                section_replaced = True
                in_gene_expression = False

            if not in_gene_expression:
                patched_lines.append(line)

        # Edge case: if gene-expression was last section and never replaced
        if in_gene_expression and not section_replaced:
            patched_lines.append("[gene-expression]\n")
            patched_lines.append("create-bam,true\n")
            patched_lines.append(f"reference,{self.ref_genome}\n")
            patched_lines.append(f"probe-set,{self.probe_file}\n")

        with open(config_dest, "w") as file:
            file.writelines(patched_lines)

        # Debug: Print the patched file
        print("Patched multi_config.csv:")
        with open(config_dest, "r") as file:
            print(file.read())

    def run_cellranger_multi(self):
        """
        Runs the Cell Ranger 'multi' command with required environment modules loaded.

        This method performs the following steps:
        1. Loads necessary modules (Bioinformatics, cellranger, snakemake) using the environment's module system.
        2. Ensures the logs directory exists.
        3. Deletes the output directory if it already exists to avoid conflicts.
        4. Verifies the presence of the Cell Ranger multi configuration CSV file.
        5. Constructs and executes the Cell Ranger 'multi' command with the specified configuration and output directory.

        Raises:
            FileNotFoundError: If the Cell Ranger multi configuration CSV file does not exist.
            subprocess.CalledProcessError: If the command execution fails.
        """
        """Run the Cell Ranger multi command with module loading."""
        print("üöÄ Running Cell Ranger multi with module loading...")

        # Define the module commands
        module_commands = (
            "set +u && "
            "module purge && "
            "module load Bioinformatics cellranger && "
            "module load snakemake && "
            "set -u"
        )

        # Define the Cell Ranger command
        output_dir = self.results_dir
        config_file = self.project_path / "config" / "cellranger_multi_config.csv"

        # Ensure the logs directory exists
        self.logs_dir.mkdir(parents=True, exist_ok=True)

        # Delete the output directory if it exists
        if output_dir.exists():
            print(f"‚ö†Ô∏è Output directory {output_dir} already exists. Deleting it to avoid conflicts.")
            shutil.rmtree(output_dir)

        # Verify the multi_config.csv file exists
        if not Path(config_file).exists():
            raise FileNotFoundError(f"multi_config.csv not found at {config_file}")

        # Properly quote the path to handle spaces
        quoted_config_file = f'"{config_file}"'
        quoted_output_dir = f'"{output_dir}"'

        cellranger_command = (
            f"cellranger multi --id={self.output_id} "
            f"--csv={quoted_config_file} "
            f"--output-dir={quoted_output_dir}"
        )

        # Combine the commands
        full_command = f"{module_commands} && {cellranger_command}"

        print(f"Executing command: {full_command}")
        subprocess.run(full_command, shell=True, check=True)
        
    def build_cellranger_command(self):
        """Build the full shell command for SLURM submission."""
        module_commands = (
            "set +u && "
            "module purge && "
            "module load Bioinformatics cellranger && "
            "module load snakemake && "
            "set -u"
        )

        config_file = self.project_path / "config" / "cellranger_multi_config.csv"
        output_dir = self.results_dir

        quoted_config_file = f'"{config_file}"'
        quoted_output_dir = f'"{output_dir}"'

        cellranger_command = (
            f"cellranger multi --id={self.output_id} "
            f"--csv={quoted_config_file} "
            f"--output-dir={quoted_output_dir}"
        )

        return f"{module_commands} && {cellranger_command}"

    def run(self):
        """Execute the Cell Ranger workflow."""
        print(f"üî¨ Starting {self.workflow_name}...")
        self.validate_paths()
        self.prepare_multi_config()
        
        #self.run_cellranger_multi()


        command = self.build_cellranger_command()
        
        job_id = self.submit_job(
            command=command,
            job_name=f"cellranger_{self.output_id}",
            dry_run=False  # ‚úÖ Generates .slurm only
        )
        
        if job_id:
            print(f"‚úÖ SLURM job submitted for {self.workflow_name} (Job ID: {job_id})")
        else:
            print(f"‚úÖ Job for {self.workflow_name} was run locally or as a dry run.")
        
        print(f"‚úÖ {self.workflow_name} completed successfully!")